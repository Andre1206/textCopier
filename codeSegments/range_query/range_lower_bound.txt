template<class T, T F(T a, T b)> class range_lower_bound{ //限制：T 可比大小
    private:
    inline int mid(int a, int b){
        return (a+b)>>1;
    }
    class node{
        public:
        T val;
        int L;
        int R;
        node* left;
        node* right;
        node(T a, int b, int c) : val(a), L(b), R(c), left(nullptr), right(nullptr){
        }
        node(T a, int b, int c, node* d, node* e) : val(a), L(b), R(c), left(d), right(e){
        }
    };
    node* root;
    pair<int, T> lower_bound(node* root, int index, const T& target){
        if(root->L==root->R){
            if(root->val<target){
                return {-1, root->val};
            }
            else{
                return {index, root->val};
            }
        }
        if(root->left->R<index){
            return lower_bound(root->right, index, target);
        }
        pair<int, T> left_hint=lower_bound(root->left, index, target);
        if(left_hint.first!=-1) return left_hint;
        T potential=F(left_hint.second, root->right->val);
        if(potential<target) return {-1, potential};
        T helper=left_hint.second;
        node* locator=root->right;
        while(locator->L!=locator->R){
            T new_helper=F(helper, locator->left->val);
            if(!(new_helper<target)){
                locator=locator->left;
            }
            else{
                helper=new_helper;
                locator=locator->right;
            }
        }
        return {locator->L, helper};
    }
    void iterate(node* root, vector<T>& arr){
        if(root->L==root->R){
            arr.push_back(root->val);
            return;
        }
        iterate(root->left, arr);
        iterate(root->right, arr);
    }
    public:
    range_lower_bound(const vector<T>& a){
        function<node*(int, int)> initialize=[&](int l, int r){
            if(l==r){
                return new node(a[l], l, r);
            }
            node* ptr_l=initialize(l, mid(l, r));
            node* ptr_r=initialize(mid(l, r)+1, r);
            return new node(F(ptr_l->val, ptr_r->val), l, r, ptr_l, ptr_r);
        };
        root=initialize(0, a.size()-1);
    }
    T S(int a, int b){
        if(a>b){
            cout << "S(a,b) is called when a=" << a << ">" << b << "=b" << endl;
            return T();
        }
        function<T(node*, int, int)> solve=[&](node* ptr, int index_l, int index_r){
            if(ptr->L==index_l && ptr->R==index_r){
                return ptr->val;
            }
            int m=mid(ptr->L, ptr->R);
            if(index_l>m){
                return solve(ptr->right, index_l, index_r);
            }
            if(index_r<=m){
                return solve(ptr->left, index_l, index_r);
            }
            return F(solve(ptr->left, index_l, m), solve(ptr->right, m+1, index_r) );
        };
        return solve(root, a, b);
    }
    void renew(int index, T new_val){
        function<void(node*)> renew_node=[&](node* ptr){
            if(ptr->L==ptr->R){
                ptr->val=new_val;
                return;
            }
            int m=mid(ptr->L, ptr->R);
            if(index<=m){
                renew_node(ptr->left);
            }
            else{
                renew_node(ptr->right);
            }
            ptr->val=F(ptr->left->val, ptr->right->val);
        };
        renew_node(root);
    }
    int lower_bound(int index, const T& target){
        return lower_bound(root, index, target).first;
    }
    int size(){
        return root->R+1;
    }
    T operator [](int index){
        function<T(node*)> get_val=[&](node* ptr){
            if(ptr->L==ptr->R){
                return ptr->val;
            }
            int m=mid(ptr->L, ptr->R);
            if(index<=m){
                return get_val(ptr->left);
            }
            else{
                return get_val(ptr->right);
            }
        };
        return get_val(root);
    }
    vector<T> iterate(){
        vector<T> ans;
        iterate(root, ans);
        return ans;
    }
//tester: LeetCode 2286, 2940, ABC 389F
};