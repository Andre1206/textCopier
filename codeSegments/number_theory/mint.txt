template<int q> class int_module{
    int val;
    public:
    int_module() = default;
    int_module(long long x) {
        val = (x % q + q) % q;
    }
    bool operator ==(const int_module<q>& a) const {
        return val == a.val;
    }
    bool operator ==(const long long& a) const {
        return (a % q - val) % q == 0;
    }
    bool operator !=(const int_module<q>& a) const {
        return val != a.val;
    }
    bool operator !=(const long long& a) const {
        return (a % q - val) % q != 0;
    }
    int_module& operator +=(const int_module<q>& a) {
        val += a.val;
        if (val >= q) val -= q;
        return *this;
    }
    int_module& operator +=(const long long& a) {
        return *this += int_module(a);
    }
    int_module operator +(const int_module<q>& a) const {
        int_module res = *this;
        res += a;
        return res;
    }
    int_module operator +(const long long& a) const {
        int_module res = *this;
        res += a;
        return res;
    }
    int_module operator -() const {
        int_module res = *this;
        if (res.val > 0) res.val = q - res.val;
        return res;
    }
    int_module& operator -=(const int_module<q>& a) {
        val -= a.val;
        if (val < 0) val += q;
        return *this;
    }
    int_module& operator -=(const long long& a) {
        return *this -= int_module(a);
    }
    int_module operator -(const int_module<q>& a) const {
        int_module res = *this;
        res -= a;
        return res;
    }
    int_module operator -(const long long& a) const {
        int_module res = *this;
        res -= a;
        return res;
    }
    int_module& operator *=(const int_module<q>& a) {
        val = ((long long)val * a.val) % q;
        return *this;
    }
    int_module& operator *=(const long long& a) {
        return *this *= int_module(a);
    }
    int_module operator *(const int_module<q>& a) const {
        int_module res = *this;
        res *= a;
        return res;
    }
    int_module operator *(const long long& a) const {
        int_module res = *this;
        res *= a;
        return res;
    }
    void print() const {
        cout << val << endl;
    }
    void set_val(long long x) {
        val = (x % q + q) % q;
    }
    int get_val() const {
        return val;
    }
    int_module inv() const {
        long long a = q, m = val;
        long long x = 0, y = 1;
        while (m) {
            long long t = a / m;
            a -= t * m; swap(a, m);
            x -= t * y; swap(x, y);
        }
        if (a != 1) {
            throw runtime_error("No modular inverse exists");
        }
        return int_module(x);
    }
    bool invertible() const {
        long long a = q, m = val;
        while (m) {
            long long t = a % m;
            a = m;
            m = t;
        }
        return a == 1;
    }
    int_module& operator /=(const int_module<q>& a) {
        return *this *= a.inv();
    }
    int_module& operator /=(const long long& a) {
        return *this *= int_module(a).inv();
    }
    int_module operator /(const int_module<q>& a) const {
        int_module res = *this;
        res /= a;
        return res;
    }
    int_module operator /(const long long& a) const {
        int_module res = *this;
        res /= a;
        return res;
    }
    int_module pow(long long x) const {
        int_module base = *this;
        int_module res(1);
        if (x < 0) {
            base = base.inv();
            x = -x;
        }
        while(x) {
            if(x & 1) res *= base;
            base *= base;
            x >>= 1;
        }
        return res;
    }
    friend ostream& operator<<(ostream& os, const int_module<q>& a) {
        return os << a.val;
    }
    friend istream& operator>>(istream& is, int_module<q>& a) {
        long long x;
        is >> x;
        a.set_val(x);
        return is;
    }
}; //tester: ABC 310F, ABC 405E
const int _p=1000000007;
const int _q=998244353;
typedef int_module<_q> mint;

vector<mint> fac;
vector<mint> inv_fac;
void init_fac(int N, bool init_inv = true) {
    fac.resize(N+1);
    fac[0] = 1;
    for(int i = 1; i <= N; ++i) {
        fac[i] = fac[i-1] * i;
    }
    if (init_inv) {
        inv_fac.resize(N+1);
        inv_fac[0] = 1;
        for(int i=1; i <= N; ++i) {
            inv_fac[i] = fac[i].inv();
        }
    }
}
